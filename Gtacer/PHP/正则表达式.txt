/* $pattern=正则表达式
   $subject=匹配的目标数据  */

preg_match($pattern,$subject，[array &$matches])
	//返回匹配的到结果的次数，只匹配一次，结果储存到数组matches中

preg_match_all($pattern,$subject,array &$matches)
	//返回匹配的到结果的次数，返回所有相匹配的结果，结果储存到数组matches中



preg_replace($pattern,$replacement,$subject)
	//将匹配到的值替换为$replacement中的值，如果$subject为一个数组，保留没有发生替换的字符串

preg_filter($pattern,$replacement,$subject)
	//将匹配到的值替换为$replacement中的值，如果$subject为一个数组，则只保留发生了替换的字符串。


preg_grep($pattern,array $input)
	//将无法被正则表达式匹配到的值过滤掉，并将剩下的值返回为一个数组


preg_split($pattern,$subject)
	//将匹配到的字符串作为分割点，分隔$subject,将分割到的多个字符串返回一个为数组的结果


preg_quote($str)
	//讲一个字符串中的所有正则表达式运算符进行转义




界定符
	表示一个正则表达式的开始和结束（/……/ #……# ...）

元字符
	|	匹配两个或者多个分支选择

	[]	匹配方括号中的任意一个原子

	[^]	匹配除方括号中的原子之外的任意字符

	.	匹配除换行符之外的任意字符

	\d	匹配任意一个十进制数字，即[0-9]

	\D	匹配任意一个非十进制数字，即^[0-9]

	\s	匹配一个不可见原子，即[\f\n\r\t\v]

	\S	匹配一个可见原子，即[^\f\n\r\t\v]

	\w	匹配任意一个数字、字母或下划线，即[0-9a-zA-Z]

	\W	匹配任意一个非数字、字母、或下划线，即[^0-9a-zA-Z]

量词
	{n}	表示其前面的原子恰好出现n次

	{n,}	表示其前面的原子最少次出现n次

	{n,m}	表示其前面的原子最少出现n次，最多出现m次

	*	匹配0次、1次或者多次其之前的原子，即{0,}

	+	匹配1次或者多次其之前的原子，即{1,}

	?	匹配0次或者一次其之前的原子，即{0,1}

边界控制与模式单元
	^	匹配字符串开始的位置

	$	匹配字符串结尾的位置

	()	匹配其中的整体为一个原子



修正模式
	懒惰匹配（/……/U）
		-匹配结果存在歧义时取其短
		
	贪婪匹配（默认 /……/u）
		-匹配结果存在歧义时取其长

	i	-忽略英文字母大小写

	x	-忽略正则表达式中的空白

	s	-让字符'.'匹配包括换行符在内的所有字符
